<i><b>Note:</b> This post summarizes the techniques discussed in Corelan <a href="https://www.corelan.be/index.php/2009/07/23/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-2/" target="_blank">post</a> on jumping to shellcode. Read it for better understanding.</i><br /><br />So you managed to control EIP and you want to jump to your shellcode. Check the condition for each technique and see if you can make it work to reach your shellcode.<br /><br /><h3>1. JMP/CALL register</h3><u><b>Conditions:</b></u> <br />&nbsp;&nbsp;&nbsp; ○ A register points to shellcode.<br /><u><b>Example: </b></u><br />&nbsp;&nbsp;&nbsp; ○ [Register] → [Shellcode]<br />&nbsp;&nbsp;&nbsp; ○ EIP → JMP/CALL [register]<br />&nbsp;&nbsp;&nbsp; ○ EIP now points to [register] where shellcode.<br /><u><b>Pros:</b></u><br />&nbsp;&nbsp;&nbsp; ○ Easy to apply.<br />&nbsp;&nbsp;&nbsp; ○ Common instruction.<br /><u><b>Cons:</b></u><br />&nbsp;&nbsp;&nbsp; ○ None.<br /><br /><h3>2. POP RET / POP POP RET / POP POP POP RET</h3><u><b>Condition: </b></u><br />&nbsp;&nbsp;&nbsp; ○ Address at [ESP+4], [ESP+8], [ESP+12] (and so on) points to address to shellcode <b>OR </b>directly to shellcode.<br /><u><b>Example 1: </b></u><br />&nbsp;&nbsp;&nbsp; ○ [ESP] → [4 bytes][Address to shellcode].<br />&nbsp;&nbsp;&nbsp; ○ EIP → POP [register] followed by RET.<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; § POP [register]: ESP now points to old_ESP + 4<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; § RET: EIP now contains address to shellcode.<br />&nbsp;&nbsp;&nbsp; ○ EIP now points to shellcode.<br /><u><b>Example 2: </b></u><br />&nbsp;&nbsp;&nbsp; ○ [ESP] → [8 bytes][Address to JMP ESP][shellcode].<br />&nbsp;&nbsp;&nbsp; ○ EIP → POP [register] followed by POP [register] followed by RET:<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; § POP [register], POP [register] will get rid of 8 bytes, new ESP → old ESP + 8 (Address to JMP ESP)<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; § RET places address to JMP ESP in EIP and now ESP now points to shellcode.<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; § JMP ESP: EIP now contains ESP<br />&nbsp;&nbsp;&nbsp; ○ EIP points to current ESP value which points to start of shellcode.<br /><u><b>Pros:</b></u><br />&nbsp;&nbsp;&nbsp; ○ Straightforward (slightly harder than method 1).<br />&nbsp;&nbsp;&nbsp; ○ Lots of possible combinations to find instruction.<br />Cons:<br />&nbsp;&nbsp;&nbsp; ○ Less frequent pattern.<br /><br /><h3>3. PUSH&nbsp; RET</h3><u><b>Condition: </b></u><br />&nbsp;&nbsp;&nbsp; ○ A register points to shellcode and can't/don't want to use method 1.<br /><u><b>Example: </b></u><br />&nbsp;&nbsp;&nbsp; ○ [Register]→ [Shellcode]<br />&nbsp;&nbsp;&nbsp; ○ EIP → PUSH [register], followed by RET<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; § Stack will first push register, then pop it to EIP. <br />&nbsp;&nbsp;&nbsp; ○ EIP now points to shellcode.<br /><u><b>Pros:</b></u><br />&nbsp;&nbsp;&nbsp; ○ Easy to apply.<br />&nbsp;&nbsp;&nbsp; ○ Fallback if method 1 can't be done.<br /><u><b>Cons:</b></u><br />&nbsp;&nbsp;&nbsp; ○ None.<br /><br /><h3>4. JMP [register + offset]</h3><u><b>Condition: </b></u><br />&nbsp;&nbsp;&nbsp; ○ A register + offset points to shellcode.<br /><u><b>Example: </b></u><br />&nbsp;&nbsp;&nbsp; ○ [Register] → [Shellcode]<br />&nbsp;&nbsp;&nbsp; ○ EIP → JMP [register + offset]<br />&nbsp;&nbsp;&nbsp; ○ EIP will point to [register + offset] where the shellcode starts.<br /><u><b>Pros:</b></u><br />&nbsp;&nbsp;&nbsp; ○ Easy to apply.<br /><u><b>Cons:</b></u><br />&nbsp;&nbsp;&nbsp; ○ Doesn't work if [register + offset] points to address to shellcode as ESP doesn't change and a RET won't work.<br />&nbsp;&nbsp;&nbsp; <br /><h3>5. Blind return</h3><u><b>Condition: </b></u><br />&nbsp;&nbsp;&nbsp; ○ Shellcode is always loaded to the same address.<br />&nbsp;&nbsp;&nbsp; ○ Address doesn't contain a null byte.<br />&nbsp;&nbsp;&nbsp; ○ You control at least the first 4 bytes at [ESP]<br /><u><b>Example: </b></u><br />&nbsp;&nbsp;&nbsp; ○ Shellcode is always at 0xdeadbeef<br />&nbsp;&nbsp;&nbsp; ○ Since you control the first 4 bytes at ESP, put 0xdeadbeef at ESP.<br />&nbsp;&nbsp;&nbsp; ○ By pointing EIP to a RET, address at ESP will be popped to EIP.<br />&nbsp;&nbsp;&nbsp; ○ EIP now points to address 0xdeadbeef where the shellcode starts.<br /><u><b>Pros:</b></u><br />&nbsp;&nbsp;&nbsp; ○ Easiest method, only need a RET.<br />&nbsp;&nbsp;&nbsp; ○ Fixed address.<br /><u><b>Cons:</b></u><br />&nbsp;&nbsp;&nbsp; ○ Heavy dependency on hardcoded address.<br />&nbsp;&nbsp;&nbsp; ○ Address can't contain null byte (good luck with stack at low address).<br />&nbsp;&nbsp;&nbsp; ○ Assumes no ASLR.<br /><br /><h3>6. POPAD</h3><u><b>Condition: </b></u><br />&nbsp;&nbsp;&nbsp; ○ Shellcode is located at [ESP + 32x + offset]<br />&nbsp;&nbsp;&nbsp; ○ Enough controllable space to execute POPAD y times then JMP ESP.<br /><u><b>Example: </b></u><br />&nbsp;&nbsp;&nbsp; ○ [ESP + 240] → [Shellcode]<br />&nbsp;&nbsp;&nbsp; ○ [ESP + 32 * 7] → [NOP sled]<br />&nbsp;&nbsp;&nbsp; ○ [ESP] → POPAD 7 times followed by JMP ESP<br />&nbsp;&nbsp;&nbsp; ○ EIP → [JMP ESP]<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; § EIP will execute POPAD 7 times, ESP = old_ESP + 224<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; § EIP goes over NOP sled<br />&nbsp;&nbsp;&nbsp; ○ EIP after executing NOP sled, it will point to [ESP + 240] where the shellcode starts.<br /><u><b>Pros:</b></u><br />&nbsp;&nbsp;&nbsp; ○ POPAD is a single byte.<br />&nbsp;&nbsp;&nbsp; ○ ESP gets incremented with 32 every time POPAD is executed.<br /><u><b>Cons:</b></u><br />&nbsp;&nbsp;&nbsp; ○ Requires NOP sled.<br />&nbsp;&nbsp;&nbsp; ○ Less reliable than Method 1/2/3/4<br /><br /><h3>7. Short jumps (backwards, forwards, conditional)</h3><u><b>Condition:</b></u> <br />&nbsp;&nbsp;&nbsp; ○ Shellcode is located at [ESP + offset] where -128 &lt; offset &lt; 127.<br /><u><b>Example:</b></u> <br />&nbsp;&nbsp;&nbsp; ○ [ESP + 30] → [Shellcode]<br />&nbsp;&nbsp;&nbsp; ○ [ESP] → JMP 30<br />&nbsp;&nbsp;&nbsp; ○ EIP → [JMP ESP]<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; § EIP will execute a short JMP<br />&nbsp;&nbsp;&nbsp; ○ EIP will point to [ESP + 30] where the shellcode starts.<br /><u><b>Pros:</b></u><br />&nbsp;&nbsp;&nbsp; ○ Simple instruction.<br />&nbsp;&nbsp;&nbsp; ○ Reliable, no NOP sled is needed.<br /><u><b>Cons:</b></u><br />&nbsp;&nbsp;&nbsp; ○ Restricted by being a short JMP.<br />&nbsp;&nbsp;&nbsp; <br /><h3>8. Hardcoded address</h3><u><b>Condition: </b></u><br />&nbsp;&nbsp;&nbsp; ○ Shellcode is always located at specific address.<br /><u><b>Example: </b></u><br />&nbsp;&nbsp;&nbsp; ○ 0xdeadbeef → [shellcode]<br />&nbsp;&nbsp;&nbsp; ○ EIP → JMP ESP<br />&nbsp;&nbsp;&nbsp; ○ ESP → JMP 0xdeadbeef<br /><u><b>Pros:</b></u><br />&nbsp;&nbsp;&nbsp; ○ Simple instruction.<br /><u><b>Cons:</b></u><br />&nbsp;&nbsp;&nbsp; ○ Unreliable.<br />&nbsp;&nbsp;&nbsp; ○ Address can't contain null bytes.<br /><br />Following repo contains some snippets on various payload generation for the techniques below: <a href="https://github.com/abatchy17/ExploitDevSnippets/tree/master/Corelan">https://github.com/abatchy17/ExploitDevSnippets/tree/master/Corelan</a> 