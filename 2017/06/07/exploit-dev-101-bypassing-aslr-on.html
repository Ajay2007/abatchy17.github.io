<i><u><b>Note:</b></u> This post is quite theoretical (yuk!) but I'll work on providing a hands-on demo sometime in the future.</i><br /><br /><h2>What is ASLR?</h2>Address space layout randomization (ASLR) is a memory protection techniques that tries to prevent an attacker from creating a reliable exploit. What it does is simple, a binary is loaded at a different base address in memory upon restart (or reboot for OS dlls). It also randomizes the base addresses for memory segments like the heap and the stack. This makes it harder for attackers to guess the correct address.<br /><br />ASLR was introduced in Windows Vista and is in all newer versions. To make use of it, the executable needs to be compiled with /DYNAMICBASE option as well. OS dlls have that by default.<br /><br />A way to see this taking place is by attaching an executable supporting ASLR (WinRAR in example below). Attach it to OllyDbg and go to the memory tab (ALT+M).<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/xzRXeum.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/xzRXeum.png" data-original-height="108" data-original-width="379" height="113" width="400" /></a></div>Restart WinRAR.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://i.imgur.com/XREhveM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://i.imgur.com/XREhveM.png" data-original-height="107" data-original-width="379" height="112" width="400" /></a></div><br /><span style="font-weight: normal;">Note that the he higher two bytes get randomized, lower ones don't.</span><br /><br /><h2>How does it make exploitation harder?</h2>Most exploits require a way to redirect execution to the payload, this can be done by <a href="http://www.abatchy.com/2017/05/jumping-to-shellcode.html" target="_blank">many different ways</a>. What all these techniques got in common is finding an instruction that will "trigger" the payload by jumping to the address. Since addresses are hard coded they won't work after restart/reboot/different machine.<br /><br /><b>Example:</b> JMP ESP is at <i>0x12345678 </i>in test.dll, upon restart, address is now located at <i>0xABCD5678</i>.<br /><br /><h2>Bypassing ASLR</h2><span style="font-weight: normal;">Next I'll discuss 4 (more like 3) techniques on bypassing ASLR, each with pros, cons and study cases if any.</span><br /><span style="font-weight: normal;">&nbsp;</span> <br /><h4>1. Abusing non-ASLR enabled libraries</h4>Programmers make mistakes, to make full use of ASLR, all loaded libraries need to be supporting it. If a single module doesn't you can make use of it by finding search that library for the needed instruction to jump to your shellcode.<br /><br /><u><b>Pros:</b></u><br /><ul><li>Reliable.</li></ul><u><b>Cons: </b></u><br /><ul><li>None.<u><b><br /></b></u></li></ul><u><b>Study case:</b></u><br /><ul><li>CoolPlayer+ Portable 2.19.6 - '.m3u' Stack Overflow (Egghunter + ASLR Bypass), can be found <a href="https://www.exploit-db.com/exploits/40151/" target="_blank">here</a>. </li></ul><h4>&nbsp;</h4><h4>&nbsp;2. Partial EIP overwrite</h4>Since you control EIP, you also control how much of EIP you want to overwrite.<br />As already mentioned, ASLR only randomizes the higher two bytes, what if you can make use of that and only overwrite the lower 2 bytes?<br /><br />Example: DLL is loaded at <i>0xAABB0000</i>, if you overwrite only the lower two bytes (thanks to small endianness) you can basically control EIP to jump anywhere in <i>0xAABB0000 </i>to <i>0xAABBXXYY.</i><br /><br /><u><b>Pros:</b></u><br /><ul><li>Big pool to search for the needed instruction from (16^4).</li></ul><u><b>Cons: </b></u><br /><ul><li>Can't use bad characters.</li></ul><u><b>Study case:</b></u><br /><ul><li>MS07-017, more info can be found <a href="https://www.sans.org/reading-room/whitepapers/threats/ani-vulnerability-history-repeats-1926" target="_blank">here</a>.<u><b> </b></u></li></ul><h4>2.1 Single byte overwrite</h4>Sometimes a character gets appended to your string, for example a null byte. This will mess up with the previous technique as when you try to overwrite the lower 2 bytes of EIP it becomes <i>0xAA00XXYY</i> instead of <i>0xAABBXXYY</i>. Although this limits the possibility of finding a proper instruction, you might still be able to get away with a single byte.<br /><br />Search the 0xAABB0000 to 0xAABB00FF for possible instructions that can be used to land you your shellcode. 256 combinations aren't a lot so good luck with that.<br /><br /><u><b>Pros:</b></u><br /><ul><li>It's not over yet. </li></ul><u><b>Cons:&nbsp;</b></u><br /><ul><li>Very small search space (0x00 to 0xFF)</li><li>Still can't use bad characters.</li></ul><h4>3. Bruteforcing address space</h4>Since we know that only the 2 higher bytes are randomized, what if we try to bruteforce all the possible combination? This method is risky (might crash the service), slow and adds a lot of overhead.<br /><br /><u><b>Pros:</b></u><br /><ul><li>Unless the higher bytes contain a bad char, it should work.</li></ul><u><b>Cons:&nbsp;</b></u><br /><ul><li>Large search space (0x0000 to 0xFFFF)</li><li>Huge overhead, service might crash and not restart. </li><li>Still can't use bad characters.</li></ul><u><b>Study case:</b></u><br /><ul><li>Samba 2.2.8 (Linux x86) - 'trans2open' Overflow (Metasploit), can be found <a href="https://www.exploit-db.com/exploits/16861/" target="_blank">here</a>. </li></ul><h4>4. Ultra-luck mode</h4><br />Needed instruction is found at 0x0000XXYY, 0x0001XXYY, ... , 0xFFFFXXYY.<br /><br /><u><b>Pros:</b></u><br /><ul><li>Very cool.</li></ul><u><b>Cons:&nbsp;</b></u><br /><ul></ul><ul><li>Doesn't work.</li></ul><hr /><br />That's it! I'll work on a demo to utilize those techniques in the future.<br /><br /><ul></ul>- Abatchy <br /><ul></ul><br />