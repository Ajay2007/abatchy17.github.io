<i>This will be continuously improved as I learn more about shellcoding.</i><br /><br /><h3>1. XOR Instruction</h3>Setting a register to null is usually a problem when writing shellcode due to couple of reasons:<br /><br />1. It contains null characters, will fuck up your string.<br />2. Size limitations.<br /><br />Example:<br /><br /><div style="background: #f8f8f8; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><span style="color: #073763;">nasm &gt; mov al, 0<br />00000000&nbsp; B000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: lime;">; <span style="color: purple;"><b>2 bytes</b></span></span><br />nasm &gt; mov ax, 0<br />00000000&nbsp; 66B80000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #274e13;">; <b><span style="color: purple;">4 bytes</span></b></span><br />nasm &gt; mov eax, 0<br />00000000&nbsp; B800000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #38761d;">; <b><span style="color: purple;">5 bytes</span></b></span></span></div><br />Instead, XORing a register with itself 1) clears it out as well, 2) is null-free and 3) generates less shellcode.<br /><br /><div style="background: #f8f8f8; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><span style="color: #073763;">nasm &gt; xor al,al<br />00000000&nbsp; 30C0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <span style="color: purple;"><b>2 bytes</b></span><br />nasm &gt; xor ax,ax<br />00000000&nbsp; 6631C0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <span style="color: purple;"><b>4 bytes</b></span><br />nasm &gt; xor eax,eax<br />00000000&nbsp; 31C0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <span style="color: purple;"><b>2 bytes</b></span></span></div><br />Although <b>xor ax,ax</b> didn't generate less shellcode, it doesn't contain a null character.<br /><br /><h3>2. CBW, CWD, CDQ Instructions</h3>CBW, CWD and CDQ extends the sign bit of al/ax/eax to ah/dx/edx. This is particularly useful due to a couple of reasons:<br /><br />1. EAX is essential in system calls.<br />2. Many times you'll need a register zeroed out. As most system calls won't "set" the flag bit in EAX, calling C{B/W/D}Q is an easy way to use EDX when NULL is needed.<br /><br />Example:<br /><br /><div style="background: #f8f8f8; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><pre style="line-height: 125%; margin: 0;"><span style="color: #073763;">mov al, 5       ; al's sign bit is 0 (positive)</span></pre><pre style="line-height: 125%; margin: 0;"><span style="color: #073763;">cbw             ; ah is now 0x00</span></pre><pre style="line-height: 125%; margin: 0;"><span style="color: #073763;">&nbsp;</span></pre><pre style="line-height: 125%; margin: 0;"><span style="color: #073763;">mov ax, -5</span></pre><pre style="line-height: 125%; margin: 0;"><span style="color: #073763;">cbd             ; dx is now 0xffff</span></pre><pre style="line-height: 125%; margin: 0;"><span style="color: #073763;">&nbsp;</span></pre><pre style="line-height: 125%; margin: 0;"><span style="color: #073763;">mov eax, 1337</span></pre><pre style="line-height: 125%; margin: 0;"><span style="color: #073763;">cdq             ; eax is now 0x00000000</span></pre></div><br />A common way to set a register to zero is by XORing itself (tip 1). This is <b>2-4 bytes long</b>, while using any of the previous commands knowing/controlling the value of the corresponding register, w<b>e can reduce it to one byte</b>, cutting down the size to 50-75%.<br /><br /><div style="background: #f8f8f8; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><span style="color: #073763;"><span style="font-family: inherit;">nasm &gt; xor eax, eax<br />00000000&nbsp; 31C0</span></span><br /><span style="color: #073763;"><span style="font-family: inherit;">nasm &gt; xor edx, edx<br />00000000&nbsp; 31D2<br />nasm &gt; xor ah,ah<br />00000000&nbsp; 30E4</span></span><br /><span style="color: #073763;"><span style="font-family: inherit;">nasm &gt; cbw<br />00000000&nbsp; 6698</span></span><br /><span style="color: #073763;"><span style="font-family: inherit;">nasm &gt; cwd<br />00000000&nbsp; 6699</span></span><br /><span style="color: #073763;"><span style="font-family: inherit;">nasm &gt; cdq<br />00000000&nbsp; 99</span></span><br /><span style="color: #073763;"><span style="font-family: inherit;">nasm &gt; </span></span></div><br /><h3>3. Push 0x1, POP EAX</h3>XORing (Tip 1) is great to zero out a register, but what if we want to initialize it with a certain value?<br /><br /><div style="background: #f8f8f8; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><span style="color: #073763;"><span style="font-family: inherit;">nasm &gt; xor eax, eax<br />00000000&nbsp; 31C0</span></span><br /><span style="color: #073763;"><span style="font-family: inherit;">nasm &gt; mov al, 0x1<br />00000000&nbsp; B001</span></span></div><br />How about we utilize the stack? Pushing 0x1 for example will be automatically aligned as a DWORD.<br /><br /><div style="background: #f8f8f8; border-width: 0.1em 0.1em 0.1em 0.8em; border: solid gray; overflow: auto; padding: 0.2em 0.6em; width: auto;"><span style="color: #073763;"><span style="font-family: inherit;">nasm &gt; push byte 0x1<br />00000000&nbsp; 6A01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push byte +0x1<br />nasm &gt; pop eax<br />00000000&nbsp; 58&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop eax</span></span></div><br />- Abatchy